%----------------------------------------------------------------------------------------
%	IMPLEMENTAZIONE
%----------------------------------------------------------------------------------------

\section{Implementazione}\label{sec:implementazione}

Esporre i principali problemi affrontati durante l'effettiva realizzazione delle componenti hardware/software e illustrare le soluzioni implementative adottate. Se l'elaborato ha previsto l'utilizzo di tecnologie già disponibili sul mercato, discuterne brevemente le caratteristiche e motivarne l'adozione rispetto ad altre soluzioni assimilabili.\\

% 10000 battute
Similmente a quanto fatto nella sezione precedente, anche in questo caso le soluzioni implementative avanzate sono state suddivise per sottodomonio. Di ognuna si elencano le motivazioni e le problematiche emerse durante lo sviluppo. 

\subsection{Control Unit}
Per quanto riguarda la centralina, prima di avviare il vero e proprio sviluppo del progetto si è scelto di verificare il corretto funzionamento dei sensori, collegando ciascuno di essi alla scheda e validando l'output restituito tramite opportuni software rilasciati dal produttore. Nello specifico, siccome diversi sensori comunicano mediante protocollo I2C, è stato necessario collegare questi a una \textit{breadboard} al fine di ampliare il numero di ingressi disponibili ai GPIO SDA e SCL. Una volta completata la fase preliminare di sperimentazione si è passati alla realizzazione di una \textit{build multi-progetto} confinando le funzionalità all'interno di moduli indipendenti, al fine di semplificare l'attività di sviluppo parallela tra i membri del team. Come già anticipato nella sezione di progettazione, il progetto si compone di diversi strati, quelli più interni realizzano la logica di \textit{business} che deve essere totalmente indipendente da \textit{framework}. I livelli più esterni invece dipendo dalla libreria \href{https://pi4j.com/}{pi4j} (versione 2), la motivazione principale è stata la ricerca di un livello di astrazione che potesse nascondere gli aspetti di basso livello, permettendo così al team di concentrasi quasi esclusivamente sulla logica di \textit{business}. Ovviamente vi sono altri vantaggi derivanti dall'adozione di pi4j e possono essere riassunti in:
\begin{itemize}
    \item \underline{Facilità d'uso}: pi4j espone un'API semplice e intuitiva in Java che facilita l'interazione con la componente hardware, cioè con i pin GPIO del Raspberry;
    \item \underline{Supporto per più periferiche}: pi4j supporta anche altri dispositivi periferici connessi al Raspberry Pi come dispositivi I2C e SPI;
    \item \underline{Manutenzione}: pi4j è attivamente mantenuta da una comunità di sviluppatori, questo comporta la risoluzione di eventuali bug ed estensioni future;
    \item \underline{Grande comunità}: in rete vi sono numerose risorse (es. classi Java che modellano il comportamento di specifici sensori) e un ampio supporto per la risoluzione dei problemi;
    \item \underline{Open-source}.
\end{itemize}
Il \textit{framework} pi4j, da una parte ha agevolato lo sviluppo architetturale ma dall'altra ha reso gli \textit{script} forniti dai produttori inutilizzabili, vincolando quindi il team a riscrivere le logiche dei singoli sensori. Le classi prodotte sono quindi il risultato di una ricerca basata sugli \textit{script} dei fornitori, i \textit{datasheet} dei sensori e le risorse in rete messe a disposizione dalla \textit{community}.
\newline\newline
Siccome il software della centralina si compone di due servizi, cioè \textit{Authorization} e \textit{RoomMonitoring}, fin da subito si è optato per l'adozione del paradigma concorrente così da eseguire i due servizi in flussi di controllo separati. Nella pratica si è realizzata una classe \texttt{Engine} che aggiunge un livello di astrazione rispetto allo \texttt{ScheduledExecutorService} della libreria \texttt{java.util.concurrent}. Concretamente i servizi vengono lanciati nel seguente modo:
\lstinputlisting[caption={Setup e avvio dei servizi.}, label={lst:main}, language=Java]{code/main.java}
%
Come mostrato nel Listato \ref{lst:main}, per ogni servizio viene istanziato un \texttt{Engine} fatta eccezione per l'\texttt{awsAdapter} che, appoggiandosi sulla libreria \texttt{software.amazon.awssdk}, già esegue all'interno di un flusso di controllo indipendente.L'\texttt{awsAdapter} si occupa di inoltrare i dati prodotti dal \texttt{RoomMonitoringService} verso il \textit{backend} tramite protocollo MQTT e realizza lo \textit{shadowing} tra la centralina e la sua copia digitale. 
Inoltre l'\texttt{awsAdapter} registra l'\texttt{AuthorizationService} come "osservatore" così da notificargli eventuali modifiche del \textit{token} di accesso. Infine, l'avvio dei servizi avviene solamente conclusa la procedura di \textit{bootstrap}, cioè di connessione con il \textit{backend}.
\newline\newline
Internamente il \texttt{RoomMonitoringService} (Listato \ref*{lst:rms}) esegue ogni $N$ secondi il calcolo dei consumi (corrente e acqua divisa in calda e fredda) e rileva i fattori ambientali della stanza (temperatura, umidità, luminosità). I dati raccolti vengono prima serializzati e poi inviati verso l'esterno. I consumi vengono calcolati più volte durante gli $N$ secondi, infatti è prevista una logica di aggregazione. Tutte le funzionalità implementante sono asincrone poiché si avvalgono delle \texttt{CompletableFuture} di Java.
\lstinputlisting[caption={Logica \textit{core} del \texttt{RoomMonitoringService}.}, label={lst:rms}, language=Java]{code/RoomMonitoringService.java}
%
L'\texttt{AuthorizationService} esegue solo un \textit{task} bloccante definito in due step: \texttt{bootstrap()} e \texttt{startNfcTagEmulation()}. Il primo provvede a sincronizzare lo stato della centralina con quello memorizzato sul \textit{backend}, mentre il secondo abilita la connessione tra lo smartphone e il lettore NFC. Come mostrato nel Listato \ref*{lst:as}, la funzione \texttt{startNfcTagEmulation} viene ripetuta anche nel caso di due errori specifici. Quest'ultimi non sono considerati fatali poiché possono essere provocati, per esempio da un allontamento precoce dello smartphone dal lettore.
\lstinputlisting[caption={Logica \textit{core} dell'\texttt{AuthorizationService}.}, label={lst:as}, language=Java]{code/AuthorizationService.java}
%
Il codice del programma che permette di convertire i dati ottenuti dal sensore BH1750 in \texttt{lux} (Listato \ref*{lst:bh}), si avvale della classe \texttt{I2C} di Pi4j che, grazie al metodo \texttt{read}, restituisce i due byte (LSB e MSB) necessari per produrre il risultato.
\lstinputlisting[caption={Progammazione del modulo BH1750.}, label={lst:bh}, language=Java]{code/BH1750.java}
%
% todo parlare del modulo dth22 e del multidigital purpose
\newpage